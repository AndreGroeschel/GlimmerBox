// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'open_sea_api_failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$OpenSeaApiFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidApiKey,
    required TResult Function() connectionTimeout,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() badCertificate,
    required TResult Function(String? message) badResponse,
    required TResult Function() cancel,
    required TResult Function() connectionError,
    required TResult Function() unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidApiKey,
    TResult? Function()? connectionTimeout,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? badCertificate,
    TResult? Function(String? message)? badResponse,
    TResult? Function()? cancel,
    TResult? Function()? connectionError,
    TResult? Function()? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidApiKey,
    TResult Function()? connectionTimeout,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? badCertificate,
    TResult Function(String? message)? badResponse,
    TResult Function()? cancel,
    TResult Function()? connectionError,
    TResult Function()? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OpenSeaInvalidApiKey value) invalidApiKey,
    required TResult Function(OpenSeaConnectionTimeout value) connectionTimeout,
    required TResult Function(OpenSeaSendTimeout value) sendTimeout,
    required TResult Function(OpenSeaReceiveTimeout value) receiveTimeout,
    required TResult Function(OpenSeaBadCertificate value) badCertificate,
    required TResult Function(OpenSeaBadResponse value) badResponse,
    required TResult Function(OpenSeaCancel value) cancel,
    required TResult Function(OpenSeaConnectionError value) connectionError,
    required TResult Function(OpenSeaUnknown value) unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(OpenSeaInvalidApiKey value)? invalidApiKey,
    TResult? Function(OpenSeaConnectionTimeout value)? connectionTimeout,
    TResult? Function(OpenSeaSendTimeout value)? sendTimeout,
    TResult? Function(OpenSeaReceiveTimeout value)? receiveTimeout,
    TResult? Function(OpenSeaBadCertificate value)? badCertificate,
    TResult? Function(OpenSeaBadResponse value)? badResponse,
    TResult? Function(OpenSeaCancel value)? cancel,
    TResult? Function(OpenSeaConnectionError value)? connectionError,
    TResult? Function(OpenSeaUnknown value)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OpenSeaInvalidApiKey value)? invalidApiKey,
    TResult Function(OpenSeaConnectionTimeout value)? connectionTimeout,
    TResult Function(OpenSeaSendTimeout value)? sendTimeout,
    TResult Function(OpenSeaReceiveTimeout value)? receiveTimeout,
    TResult Function(OpenSeaBadCertificate value)? badCertificate,
    TResult Function(OpenSeaBadResponse value)? badResponse,
    TResult Function(OpenSeaCancel value)? cancel,
    TResult Function(OpenSeaConnectionError value)? connectionError,
    TResult Function(OpenSeaUnknown value)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OpenSeaApiFailureCopyWith<$Res> {
  factory $OpenSeaApiFailureCopyWith(
          OpenSeaApiFailure value, $Res Function(OpenSeaApiFailure) then) =
      _$OpenSeaApiFailureCopyWithImpl<$Res, OpenSeaApiFailure>;
}

/// @nodoc
class _$OpenSeaApiFailureCopyWithImpl<$Res, $Val extends OpenSeaApiFailure>
    implements $OpenSeaApiFailureCopyWith<$Res> {
  _$OpenSeaApiFailureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$OpenSeaInvalidApiKeyImplCopyWith<$Res> {
  factory _$$OpenSeaInvalidApiKeyImplCopyWith(_$OpenSeaInvalidApiKeyImpl value,
          $Res Function(_$OpenSeaInvalidApiKeyImpl) then) =
      __$$OpenSeaInvalidApiKeyImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$OpenSeaInvalidApiKeyImplCopyWithImpl<$Res>
    extends _$OpenSeaApiFailureCopyWithImpl<$Res, _$OpenSeaInvalidApiKeyImpl>
    implements _$$OpenSeaInvalidApiKeyImplCopyWith<$Res> {
  __$$OpenSeaInvalidApiKeyImplCopyWithImpl(_$OpenSeaInvalidApiKeyImpl _value,
      $Res Function(_$OpenSeaInvalidApiKeyImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$OpenSeaInvalidApiKeyImpl implements OpenSeaInvalidApiKey {
  const _$OpenSeaInvalidApiKeyImpl();

  @override
  String toString() {
    return 'OpenSeaApiFailure.invalidApiKey()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OpenSeaInvalidApiKeyImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidApiKey,
    required TResult Function() connectionTimeout,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() badCertificate,
    required TResult Function(String? message) badResponse,
    required TResult Function() cancel,
    required TResult Function() connectionError,
    required TResult Function() unknown,
  }) {
    return invalidApiKey();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidApiKey,
    TResult? Function()? connectionTimeout,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? badCertificate,
    TResult? Function(String? message)? badResponse,
    TResult? Function()? cancel,
    TResult? Function()? connectionError,
    TResult? Function()? unknown,
  }) {
    return invalidApiKey?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidApiKey,
    TResult Function()? connectionTimeout,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? badCertificate,
    TResult Function(String? message)? badResponse,
    TResult Function()? cancel,
    TResult Function()? connectionError,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (invalidApiKey != null) {
      return invalidApiKey();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OpenSeaInvalidApiKey value) invalidApiKey,
    required TResult Function(OpenSeaConnectionTimeout value) connectionTimeout,
    required TResult Function(OpenSeaSendTimeout value) sendTimeout,
    required TResult Function(OpenSeaReceiveTimeout value) receiveTimeout,
    required TResult Function(OpenSeaBadCertificate value) badCertificate,
    required TResult Function(OpenSeaBadResponse value) badResponse,
    required TResult Function(OpenSeaCancel value) cancel,
    required TResult Function(OpenSeaConnectionError value) connectionError,
    required TResult Function(OpenSeaUnknown value) unknown,
  }) {
    return invalidApiKey(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(OpenSeaInvalidApiKey value)? invalidApiKey,
    TResult? Function(OpenSeaConnectionTimeout value)? connectionTimeout,
    TResult? Function(OpenSeaSendTimeout value)? sendTimeout,
    TResult? Function(OpenSeaReceiveTimeout value)? receiveTimeout,
    TResult? Function(OpenSeaBadCertificate value)? badCertificate,
    TResult? Function(OpenSeaBadResponse value)? badResponse,
    TResult? Function(OpenSeaCancel value)? cancel,
    TResult? Function(OpenSeaConnectionError value)? connectionError,
    TResult? Function(OpenSeaUnknown value)? unknown,
  }) {
    return invalidApiKey?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OpenSeaInvalidApiKey value)? invalidApiKey,
    TResult Function(OpenSeaConnectionTimeout value)? connectionTimeout,
    TResult Function(OpenSeaSendTimeout value)? sendTimeout,
    TResult Function(OpenSeaReceiveTimeout value)? receiveTimeout,
    TResult Function(OpenSeaBadCertificate value)? badCertificate,
    TResult Function(OpenSeaBadResponse value)? badResponse,
    TResult Function(OpenSeaCancel value)? cancel,
    TResult Function(OpenSeaConnectionError value)? connectionError,
    TResult Function(OpenSeaUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (invalidApiKey != null) {
      return invalidApiKey(this);
    }
    return orElse();
  }
}

abstract class OpenSeaInvalidApiKey implements OpenSeaApiFailure {
  const factory OpenSeaInvalidApiKey() = _$OpenSeaInvalidApiKeyImpl;
}

/// @nodoc
abstract class _$$OpenSeaConnectionTimeoutImplCopyWith<$Res> {
  factory _$$OpenSeaConnectionTimeoutImplCopyWith(
          _$OpenSeaConnectionTimeoutImpl value,
          $Res Function(_$OpenSeaConnectionTimeoutImpl) then) =
      __$$OpenSeaConnectionTimeoutImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$OpenSeaConnectionTimeoutImplCopyWithImpl<$Res>
    extends _$OpenSeaApiFailureCopyWithImpl<$Res,
        _$OpenSeaConnectionTimeoutImpl>
    implements _$$OpenSeaConnectionTimeoutImplCopyWith<$Res> {
  __$$OpenSeaConnectionTimeoutImplCopyWithImpl(
      _$OpenSeaConnectionTimeoutImpl _value,
      $Res Function(_$OpenSeaConnectionTimeoutImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$OpenSeaConnectionTimeoutImpl implements OpenSeaConnectionTimeout {
  const _$OpenSeaConnectionTimeoutImpl();

  @override
  String toString() {
    return 'OpenSeaApiFailure.connectionTimeout()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OpenSeaConnectionTimeoutImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidApiKey,
    required TResult Function() connectionTimeout,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() badCertificate,
    required TResult Function(String? message) badResponse,
    required TResult Function() cancel,
    required TResult Function() connectionError,
    required TResult Function() unknown,
  }) {
    return connectionTimeout();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidApiKey,
    TResult? Function()? connectionTimeout,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? badCertificate,
    TResult? Function(String? message)? badResponse,
    TResult? Function()? cancel,
    TResult? Function()? connectionError,
    TResult? Function()? unknown,
  }) {
    return connectionTimeout?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidApiKey,
    TResult Function()? connectionTimeout,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? badCertificate,
    TResult Function(String? message)? badResponse,
    TResult Function()? cancel,
    TResult Function()? connectionError,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (connectionTimeout != null) {
      return connectionTimeout();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OpenSeaInvalidApiKey value) invalidApiKey,
    required TResult Function(OpenSeaConnectionTimeout value) connectionTimeout,
    required TResult Function(OpenSeaSendTimeout value) sendTimeout,
    required TResult Function(OpenSeaReceiveTimeout value) receiveTimeout,
    required TResult Function(OpenSeaBadCertificate value) badCertificate,
    required TResult Function(OpenSeaBadResponse value) badResponse,
    required TResult Function(OpenSeaCancel value) cancel,
    required TResult Function(OpenSeaConnectionError value) connectionError,
    required TResult Function(OpenSeaUnknown value) unknown,
  }) {
    return connectionTimeout(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(OpenSeaInvalidApiKey value)? invalidApiKey,
    TResult? Function(OpenSeaConnectionTimeout value)? connectionTimeout,
    TResult? Function(OpenSeaSendTimeout value)? sendTimeout,
    TResult? Function(OpenSeaReceiveTimeout value)? receiveTimeout,
    TResult? Function(OpenSeaBadCertificate value)? badCertificate,
    TResult? Function(OpenSeaBadResponse value)? badResponse,
    TResult? Function(OpenSeaCancel value)? cancel,
    TResult? Function(OpenSeaConnectionError value)? connectionError,
    TResult? Function(OpenSeaUnknown value)? unknown,
  }) {
    return connectionTimeout?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OpenSeaInvalidApiKey value)? invalidApiKey,
    TResult Function(OpenSeaConnectionTimeout value)? connectionTimeout,
    TResult Function(OpenSeaSendTimeout value)? sendTimeout,
    TResult Function(OpenSeaReceiveTimeout value)? receiveTimeout,
    TResult Function(OpenSeaBadCertificate value)? badCertificate,
    TResult Function(OpenSeaBadResponse value)? badResponse,
    TResult Function(OpenSeaCancel value)? cancel,
    TResult Function(OpenSeaConnectionError value)? connectionError,
    TResult Function(OpenSeaUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (connectionTimeout != null) {
      return connectionTimeout(this);
    }
    return orElse();
  }
}

abstract class OpenSeaConnectionTimeout implements OpenSeaApiFailure {
  const factory OpenSeaConnectionTimeout() = _$OpenSeaConnectionTimeoutImpl;
}

/// @nodoc
abstract class _$$OpenSeaSendTimeoutImplCopyWith<$Res> {
  factory _$$OpenSeaSendTimeoutImplCopyWith(_$OpenSeaSendTimeoutImpl value,
          $Res Function(_$OpenSeaSendTimeoutImpl) then) =
      __$$OpenSeaSendTimeoutImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$OpenSeaSendTimeoutImplCopyWithImpl<$Res>
    extends _$OpenSeaApiFailureCopyWithImpl<$Res, _$OpenSeaSendTimeoutImpl>
    implements _$$OpenSeaSendTimeoutImplCopyWith<$Res> {
  __$$OpenSeaSendTimeoutImplCopyWithImpl(_$OpenSeaSendTimeoutImpl _value,
      $Res Function(_$OpenSeaSendTimeoutImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$OpenSeaSendTimeoutImpl implements OpenSeaSendTimeout {
  const _$OpenSeaSendTimeoutImpl();

  @override
  String toString() {
    return 'OpenSeaApiFailure.sendTimeout()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$OpenSeaSendTimeoutImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidApiKey,
    required TResult Function() connectionTimeout,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() badCertificate,
    required TResult Function(String? message) badResponse,
    required TResult Function() cancel,
    required TResult Function() connectionError,
    required TResult Function() unknown,
  }) {
    return sendTimeout();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidApiKey,
    TResult? Function()? connectionTimeout,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? badCertificate,
    TResult? Function(String? message)? badResponse,
    TResult? Function()? cancel,
    TResult? Function()? connectionError,
    TResult? Function()? unknown,
  }) {
    return sendTimeout?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidApiKey,
    TResult Function()? connectionTimeout,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? badCertificate,
    TResult Function(String? message)? badResponse,
    TResult Function()? cancel,
    TResult Function()? connectionError,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (sendTimeout != null) {
      return sendTimeout();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OpenSeaInvalidApiKey value) invalidApiKey,
    required TResult Function(OpenSeaConnectionTimeout value) connectionTimeout,
    required TResult Function(OpenSeaSendTimeout value) sendTimeout,
    required TResult Function(OpenSeaReceiveTimeout value) receiveTimeout,
    required TResult Function(OpenSeaBadCertificate value) badCertificate,
    required TResult Function(OpenSeaBadResponse value) badResponse,
    required TResult Function(OpenSeaCancel value) cancel,
    required TResult Function(OpenSeaConnectionError value) connectionError,
    required TResult Function(OpenSeaUnknown value) unknown,
  }) {
    return sendTimeout(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(OpenSeaInvalidApiKey value)? invalidApiKey,
    TResult? Function(OpenSeaConnectionTimeout value)? connectionTimeout,
    TResult? Function(OpenSeaSendTimeout value)? sendTimeout,
    TResult? Function(OpenSeaReceiveTimeout value)? receiveTimeout,
    TResult? Function(OpenSeaBadCertificate value)? badCertificate,
    TResult? Function(OpenSeaBadResponse value)? badResponse,
    TResult? Function(OpenSeaCancel value)? cancel,
    TResult? Function(OpenSeaConnectionError value)? connectionError,
    TResult? Function(OpenSeaUnknown value)? unknown,
  }) {
    return sendTimeout?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OpenSeaInvalidApiKey value)? invalidApiKey,
    TResult Function(OpenSeaConnectionTimeout value)? connectionTimeout,
    TResult Function(OpenSeaSendTimeout value)? sendTimeout,
    TResult Function(OpenSeaReceiveTimeout value)? receiveTimeout,
    TResult Function(OpenSeaBadCertificate value)? badCertificate,
    TResult Function(OpenSeaBadResponse value)? badResponse,
    TResult Function(OpenSeaCancel value)? cancel,
    TResult Function(OpenSeaConnectionError value)? connectionError,
    TResult Function(OpenSeaUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (sendTimeout != null) {
      return sendTimeout(this);
    }
    return orElse();
  }
}

abstract class OpenSeaSendTimeout implements OpenSeaApiFailure {
  const factory OpenSeaSendTimeout() = _$OpenSeaSendTimeoutImpl;
}

/// @nodoc
abstract class _$$OpenSeaReceiveTimeoutImplCopyWith<$Res> {
  factory _$$OpenSeaReceiveTimeoutImplCopyWith(
          _$OpenSeaReceiveTimeoutImpl value,
          $Res Function(_$OpenSeaReceiveTimeoutImpl) then) =
      __$$OpenSeaReceiveTimeoutImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$OpenSeaReceiveTimeoutImplCopyWithImpl<$Res>
    extends _$OpenSeaApiFailureCopyWithImpl<$Res, _$OpenSeaReceiveTimeoutImpl>
    implements _$$OpenSeaReceiveTimeoutImplCopyWith<$Res> {
  __$$OpenSeaReceiveTimeoutImplCopyWithImpl(_$OpenSeaReceiveTimeoutImpl _value,
      $Res Function(_$OpenSeaReceiveTimeoutImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$OpenSeaReceiveTimeoutImpl implements OpenSeaReceiveTimeout {
  const _$OpenSeaReceiveTimeoutImpl();

  @override
  String toString() {
    return 'OpenSeaApiFailure.receiveTimeout()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OpenSeaReceiveTimeoutImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidApiKey,
    required TResult Function() connectionTimeout,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() badCertificate,
    required TResult Function(String? message) badResponse,
    required TResult Function() cancel,
    required TResult Function() connectionError,
    required TResult Function() unknown,
  }) {
    return receiveTimeout();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidApiKey,
    TResult? Function()? connectionTimeout,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? badCertificate,
    TResult? Function(String? message)? badResponse,
    TResult? Function()? cancel,
    TResult? Function()? connectionError,
    TResult? Function()? unknown,
  }) {
    return receiveTimeout?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidApiKey,
    TResult Function()? connectionTimeout,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? badCertificate,
    TResult Function(String? message)? badResponse,
    TResult Function()? cancel,
    TResult Function()? connectionError,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (receiveTimeout != null) {
      return receiveTimeout();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OpenSeaInvalidApiKey value) invalidApiKey,
    required TResult Function(OpenSeaConnectionTimeout value) connectionTimeout,
    required TResult Function(OpenSeaSendTimeout value) sendTimeout,
    required TResult Function(OpenSeaReceiveTimeout value) receiveTimeout,
    required TResult Function(OpenSeaBadCertificate value) badCertificate,
    required TResult Function(OpenSeaBadResponse value) badResponse,
    required TResult Function(OpenSeaCancel value) cancel,
    required TResult Function(OpenSeaConnectionError value) connectionError,
    required TResult Function(OpenSeaUnknown value) unknown,
  }) {
    return receiveTimeout(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(OpenSeaInvalidApiKey value)? invalidApiKey,
    TResult? Function(OpenSeaConnectionTimeout value)? connectionTimeout,
    TResult? Function(OpenSeaSendTimeout value)? sendTimeout,
    TResult? Function(OpenSeaReceiveTimeout value)? receiveTimeout,
    TResult? Function(OpenSeaBadCertificate value)? badCertificate,
    TResult? Function(OpenSeaBadResponse value)? badResponse,
    TResult? Function(OpenSeaCancel value)? cancel,
    TResult? Function(OpenSeaConnectionError value)? connectionError,
    TResult? Function(OpenSeaUnknown value)? unknown,
  }) {
    return receiveTimeout?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OpenSeaInvalidApiKey value)? invalidApiKey,
    TResult Function(OpenSeaConnectionTimeout value)? connectionTimeout,
    TResult Function(OpenSeaSendTimeout value)? sendTimeout,
    TResult Function(OpenSeaReceiveTimeout value)? receiveTimeout,
    TResult Function(OpenSeaBadCertificate value)? badCertificate,
    TResult Function(OpenSeaBadResponse value)? badResponse,
    TResult Function(OpenSeaCancel value)? cancel,
    TResult Function(OpenSeaConnectionError value)? connectionError,
    TResult Function(OpenSeaUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (receiveTimeout != null) {
      return receiveTimeout(this);
    }
    return orElse();
  }
}

abstract class OpenSeaReceiveTimeout implements OpenSeaApiFailure {
  const factory OpenSeaReceiveTimeout() = _$OpenSeaReceiveTimeoutImpl;
}

/// @nodoc
abstract class _$$OpenSeaBadCertificateImplCopyWith<$Res> {
  factory _$$OpenSeaBadCertificateImplCopyWith(
          _$OpenSeaBadCertificateImpl value,
          $Res Function(_$OpenSeaBadCertificateImpl) then) =
      __$$OpenSeaBadCertificateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$OpenSeaBadCertificateImplCopyWithImpl<$Res>
    extends _$OpenSeaApiFailureCopyWithImpl<$Res, _$OpenSeaBadCertificateImpl>
    implements _$$OpenSeaBadCertificateImplCopyWith<$Res> {
  __$$OpenSeaBadCertificateImplCopyWithImpl(_$OpenSeaBadCertificateImpl _value,
      $Res Function(_$OpenSeaBadCertificateImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$OpenSeaBadCertificateImpl implements OpenSeaBadCertificate {
  const _$OpenSeaBadCertificateImpl();

  @override
  String toString() {
    return 'OpenSeaApiFailure.badCertificate()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OpenSeaBadCertificateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidApiKey,
    required TResult Function() connectionTimeout,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() badCertificate,
    required TResult Function(String? message) badResponse,
    required TResult Function() cancel,
    required TResult Function() connectionError,
    required TResult Function() unknown,
  }) {
    return badCertificate();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidApiKey,
    TResult? Function()? connectionTimeout,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? badCertificate,
    TResult? Function(String? message)? badResponse,
    TResult? Function()? cancel,
    TResult? Function()? connectionError,
    TResult? Function()? unknown,
  }) {
    return badCertificate?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidApiKey,
    TResult Function()? connectionTimeout,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? badCertificate,
    TResult Function(String? message)? badResponse,
    TResult Function()? cancel,
    TResult Function()? connectionError,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (badCertificate != null) {
      return badCertificate();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OpenSeaInvalidApiKey value) invalidApiKey,
    required TResult Function(OpenSeaConnectionTimeout value) connectionTimeout,
    required TResult Function(OpenSeaSendTimeout value) sendTimeout,
    required TResult Function(OpenSeaReceiveTimeout value) receiveTimeout,
    required TResult Function(OpenSeaBadCertificate value) badCertificate,
    required TResult Function(OpenSeaBadResponse value) badResponse,
    required TResult Function(OpenSeaCancel value) cancel,
    required TResult Function(OpenSeaConnectionError value) connectionError,
    required TResult Function(OpenSeaUnknown value) unknown,
  }) {
    return badCertificate(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(OpenSeaInvalidApiKey value)? invalidApiKey,
    TResult? Function(OpenSeaConnectionTimeout value)? connectionTimeout,
    TResult? Function(OpenSeaSendTimeout value)? sendTimeout,
    TResult? Function(OpenSeaReceiveTimeout value)? receiveTimeout,
    TResult? Function(OpenSeaBadCertificate value)? badCertificate,
    TResult? Function(OpenSeaBadResponse value)? badResponse,
    TResult? Function(OpenSeaCancel value)? cancel,
    TResult? Function(OpenSeaConnectionError value)? connectionError,
    TResult? Function(OpenSeaUnknown value)? unknown,
  }) {
    return badCertificate?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OpenSeaInvalidApiKey value)? invalidApiKey,
    TResult Function(OpenSeaConnectionTimeout value)? connectionTimeout,
    TResult Function(OpenSeaSendTimeout value)? sendTimeout,
    TResult Function(OpenSeaReceiveTimeout value)? receiveTimeout,
    TResult Function(OpenSeaBadCertificate value)? badCertificate,
    TResult Function(OpenSeaBadResponse value)? badResponse,
    TResult Function(OpenSeaCancel value)? cancel,
    TResult Function(OpenSeaConnectionError value)? connectionError,
    TResult Function(OpenSeaUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (badCertificate != null) {
      return badCertificate(this);
    }
    return orElse();
  }
}

abstract class OpenSeaBadCertificate implements OpenSeaApiFailure {
  const factory OpenSeaBadCertificate() = _$OpenSeaBadCertificateImpl;
}

/// @nodoc
abstract class _$$OpenSeaBadResponseImplCopyWith<$Res> {
  factory _$$OpenSeaBadResponseImplCopyWith(_$OpenSeaBadResponseImpl value,
          $Res Function(_$OpenSeaBadResponseImpl) then) =
      __$$OpenSeaBadResponseImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String? message});
}

/// @nodoc
class __$$OpenSeaBadResponseImplCopyWithImpl<$Res>
    extends _$OpenSeaApiFailureCopyWithImpl<$Res, _$OpenSeaBadResponseImpl>
    implements _$$OpenSeaBadResponseImplCopyWith<$Res> {
  __$$OpenSeaBadResponseImplCopyWithImpl(_$OpenSeaBadResponseImpl _value,
      $Res Function(_$OpenSeaBadResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = freezed,
  }) {
    return _then(_$OpenSeaBadResponseImpl(
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$OpenSeaBadResponseImpl implements OpenSeaBadResponse {
  const _$OpenSeaBadResponseImpl({required this.message});

  @override
  final String? message;

  @override
  String toString() {
    return 'OpenSeaApiFailure.badResponse(message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OpenSeaBadResponseImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$OpenSeaBadResponseImplCopyWith<_$OpenSeaBadResponseImpl> get copyWith =>
      __$$OpenSeaBadResponseImplCopyWithImpl<_$OpenSeaBadResponseImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidApiKey,
    required TResult Function() connectionTimeout,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() badCertificate,
    required TResult Function(String? message) badResponse,
    required TResult Function() cancel,
    required TResult Function() connectionError,
    required TResult Function() unknown,
  }) {
    return badResponse(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidApiKey,
    TResult? Function()? connectionTimeout,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? badCertificate,
    TResult? Function(String? message)? badResponse,
    TResult? Function()? cancel,
    TResult? Function()? connectionError,
    TResult? Function()? unknown,
  }) {
    return badResponse?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidApiKey,
    TResult Function()? connectionTimeout,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? badCertificate,
    TResult Function(String? message)? badResponse,
    TResult Function()? cancel,
    TResult Function()? connectionError,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (badResponse != null) {
      return badResponse(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OpenSeaInvalidApiKey value) invalidApiKey,
    required TResult Function(OpenSeaConnectionTimeout value) connectionTimeout,
    required TResult Function(OpenSeaSendTimeout value) sendTimeout,
    required TResult Function(OpenSeaReceiveTimeout value) receiveTimeout,
    required TResult Function(OpenSeaBadCertificate value) badCertificate,
    required TResult Function(OpenSeaBadResponse value) badResponse,
    required TResult Function(OpenSeaCancel value) cancel,
    required TResult Function(OpenSeaConnectionError value) connectionError,
    required TResult Function(OpenSeaUnknown value) unknown,
  }) {
    return badResponse(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(OpenSeaInvalidApiKey value)? invalidApiKey,
    TResult? Function(OpenSeaConnectionTimeout value)? connectionTimeout,
    TResult? Function(OpenSeaSendTimeout value)? sendTimeout,
    TResult? Function(OpenSeaReceiveTimeout value)? receiveTimeout,
    TResult? Function(OpenSeaBadCertificate value)? badCertificate,
    TResult? Function(OpenSeaBadResponse value)? badResponse,
    TResult? Function(OpenSeaCancel value)? cancel,
    TResult? Function(OpenSeaConnectionError value)? connectionError,
    TResult? Function(OpenSeaUnknown value)? unknown,
  }) {
    return badResponse?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OpenSeaInvalidApiKey value)? invalidApiKey,
    TResult Function(OpenSeaConnectionTimeout value)? connectionTimeout,
    TResult Function(OpenSeaSendTimeout value)? sendTimeout,
    TResult Function(OpenSeaReceiveTimeout value)? receiveTimeout,
    TResult Function(OpenSeaBadCertificate value)? badCertificate,
    TResult Function(OpenSeaBadResponse value)? badResponse,
    TResult Function(OpenSeaCancel value)? cancel,
    TResult Function(OpenSeaConnectionError value)? connectionError,
    TResult Function(OpenSeaUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (badResponse != null) {
      return badResponse(this);
    }
    return orElse();
  }
}

abstract class OpenSeaBadResponse implements OpenSeaApiFailure {
  const factory OpenSeaBadResponse({required final String? message}) =
      _$OpenSeaBadResponseImpl;

  String? get message;
  @JsonKey(ignore: true)
  _$$OpenSeaBadResponseImplCopyWith<_$OpenSeaBadResponseImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$OpenSeaCancelImplCopyWith<$Res> {
  factory _$$OpenSeaCancelImplCopyWith(
          _$OpenSeaCancelImpl value, $Res Function(_$OpenSeaCancelImpl) then) =
      __$$OpenSeaCancelImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$OpenSeaCancelImplCopyWithImpl<$Res>
    extends _$OpenSeaApiFailureCopyWithImpl<$Res, _$OpenSeaCancelImpl>
    implements _$$OpenSeaCancelImplCopyWith<$Res> {
  __$$OpenSeaCancelImplCopyWithImpl(
      _$OpenSeaCancelImpl _value, $Res Function(_$OpenSeaCancelImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$OpenSeaCancelImpl implements OpenSeaCancel {
  const _$OpenSeaCancelImpl();

  @override
  String toString() {
    return 'OpenSeaApiFailure.cancel()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$OpenSeaCancelImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidApiKey,
    required TResult Function() connectionTimeout,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() badCertificate,
    required TResult Function(String? message) badResponse,
    required TResult Function() cancel,
    required TResult Function() connectionError,
    required TResult Function() unknown,
  }) {
    return cancel();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidApiKey,
    TResult? Function()? connectionTimeout,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? badCertificate,
    TResult? Function(String? message)? badResponse,
    TResult? Function()? cancel,
    TResult? Function()? connectionError,
    TResult? Function()? unknown,
  }) {
    return cancel?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidApiKey,
    TResult Function()? connectionTimeout,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? badCertificate,
    TResult Function(String? message)? badResponse,
    TResult Function()? cancel,
    TResult Function()? connectionError,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (cancel != null) {
      return cancel();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OpenSeaInvalidApiKey value) invalidApiKey,
    required TResult Function(OpenSeaConnectionTimeout value) connectionTimeout,
    required TResult Function(OpenSeaSendTimeout value) sendTimeout,
    required TResult Function(OpenSeaReceiveTimeout value) receiveTimeout,
    required TResult Function(OpenSeaBadCertificate value) badCertificate,
    required TResult Function(OpenSeaBadResponse value) badResponse,
    required TResult Function(OpenSeaCancel value) cancel,
    required TResult Function(OpenSeaConnectionError value) connectionError,
    required TResult Function(OpenSeaUnknown value) unknown,
  }) {
    return cancel(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(OpenSeaInvalidApiKey value)? invalidApiKey,
    TResult? Function(OpenSeaConnectionTimeout value)? connectionTimeout,
    TResult? Function(OpenSeaSendTimeout value)? sendTimeout,
    TResult? Function(OpenSeaReceiveTimeout value)? receiveTimeout,
    TResult? Function(OpenSeaBadCertificate value)? badCertificate,
    TResult? Function(OpenSeaBadResponse value)? badResponse,
    TResult? Function(OpenSeaCancel value)? cancel,
    TResult? Function(OpenSeaConnectionError value)? connectionError,
    TResult? Function(OpenSeaUnknown value)? unknown,
  }) {
    return cancel?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OpenSeaInvalidApiKey value)? invalidApiKey,
    TResult Function(OpenSeaConnectionTimeout value)? connectionTimeout,
    TResult Function(OpenSeaSendTimeout value)? sendTimeout,
    TResult Function(OpenSeaReceiveTimeout value)? receiveTimeout,
    TResult Function(OpenSeaBadCertificate value)? badCertificate,
    TResult Function(OpenSeaBadResponse value)? badResponse,
    TResult Function(OpenSeaCancel value)? cancel,
    TResult Function(OpenSeaConnectionError value)? connectionError,
    TResult Function(OpenSeaUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (cancel != null) {
      return cancel(this);
    }
    return orElse();
  }
}

abstract class OpenSeaCancel implements OpenSeaApiFailure {
  const factory OpenSeaCancel() = _$OpenSeaCancelImpl;
}

/// @nodoc
abstract class _$$OpenSeaConnectionErrorImplCopyWith<$Res> {
  factory _$$OpenSeaConnectionErrorImplCopyWith(
          _$OpenSeaConnectionErrorImpl value,
          $Res Function(_$OpenSeaConnectionErrorImpl) then) =
      __$$OpenSeaConnectionErrorImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$OpenSeaConnectionErrorImplCopyWithImpl<$Res>
    extends _$OpenSeaApiFailureCopyWithImpl<$Res, _$OpenSeaConnectionErrorImpl>
    implements _$$OpenSeaConnectionErrorImplCopyWith<$Res> {
  __$$OpenSeaConnectionErrorImplCopyWithImpl(
      _$OpenSeaConnectionErrorImpl _value,
      $Res Function(_$OpenSeaConnectionErrorImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$OpenSeaConnectionErrorImpl implements OpenSeaConnectionError {
  const _$OpenSeaConnectionErrorImpl();

  @override
  String toString() {
    return 'OpenSeaApiFailure.connectionError()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OpenSeaConnectionErrorImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidApiKey,
    required TResult Function() connectionTimeout,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() badCertificate,
    required TResult Function(String? message) badResponse,
    required TResult Function() cancel,
    required TResult Function() connectionError,
    required TResult Function() unknown,
  }) {
    return connectionError();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidApiKey,
    TResult? Function()? connectionTimeout,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? badCertificate,
    TResult? Function(String? message)? badResponse,
    TResult? Function()? cancel,
    TResult? Function()? connectionError,
    TResult? Function()? unknown,
  }) {
    return connectionError?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidApiKey,
    TResult Function()? connectionTimeout,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? badCertificate,
    TResult Function(String? message)? badResponse,
    TResult Function()? cancel,
    TResult Function()? connectionError,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (connectionError != null) {
      return connectionError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OpenSeaInvalidApiKey value) invalidApiKey,
    required TResult Function(OpenSeaConnectionTimeout value) connectionTimeout,
    required TResult Function(OpenSeaSendTimeout value) sendTimeout,
    required TResult Function(OpenSeaReceiveTimeout value) receiveTimeout,
    required TResult Function(OpenSeaBadCertificate value) badCertificate,
    required TResult Function(OpenSeaBadResponse value) badResponse,
    required TResult Function(OpenSeaCancel value) cancel,
    required TResult Function(OpenSeaConnectionError value) connectionError,
    required TResult Function(OpenSeaUnknown value) unknown,
  }) {
    return connectionError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(OpenSeaInvalidApiKey value)? invalidApiKey,
    TResult? Function(OpenSeaConnectionTimeout value)? connectionTimeout,
    TResult? Function(OpenSeaSendTimeout value)? sendTimeout,
    TResult? Function(OpenSeaReceiveTimeout value)? receiveTimeout,
    TResult? Function(OpenSeaBadCertificate value)? badCertificate,
    TResult? Function(OpenSeaBadResponse value)? badResponse,
    TResult? Function(OpenSeaCancel value)? cancel,
    TResult? Function(OpenSeaConnectionError value)? connectionError,
    TResult? Function(OpenSeaUnknown value)? unknown,
  }) {
    return connectionError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OpenSeaInvalidApiKey value)? invalidApiKey,
    TResult Function(OpenSeaConnectionTimeout value)? connectionTimeout,
    TResult Function(OpenSeaSendTimeout value)? sendTimeout,
    TResult Function(OpenSeaReceiveTimeout value)? receiveTimeout,
    TResult Function(OpenSeaBadCertificate value)? badCertificate,
    TResult Function(OpenSeaBadResponse value)? badResponse,
    TResult Function(OpenSeaCancel value)? cancel,
    TResult Function(OpenSeaConnectionError value)? connectionError,
    TResult Function(OpenSeaUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (connectionError != null) {
      return connectionError(this);
    }
    return orElse();
  }
}

abstract class OpenSeaConnectionError implements OpenSeaApiFailure {
  const factory OpenSeaConnectionError() = _$OpenSeaConnectionErrorImpl;
}

/// @nodoc
abstract class _$$OpenSeaUnknownImplCopyWith<$Res> {
  factory _$$OpenSeaUnknownImplCopyWith(_$OpenSeaUnknownImpl value,
          $Res Function(_$OpenSeaUnknownImpl) then) =
      __$$OpenSeaUnknownImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$OpenSeaUnknownImplCopyWithImpl<$Res>
    extends _$OpenSeaApiFailureCopyWithImpl<$Res, _$OpenSeaUnknownImpl>
    implements _$$OpenSeaUnknownImplCopyWith<$Res> {
  __$$OpenSeaUnknownImplCopyWithImpl(
      _$OpenSeaUnknownImpl _value, $Res Function(_$OpenSeaUnknownImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$OpenSeaUnknownImpl implements OpenSeaUnknown {
  const _$OpenSeaUnknownImpl();

  @override
  String toString() {
    return 'OpenSeaApiFailure.unknown()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$OpenSeaUnknownImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() invalidApiKey,
    required TResult Function() connectionTimeout,
    required TResult Function() sendTimeout,
    required TResult Function() receiveTimeout,
    required TResult Function() badCertificate,
    required TResult Function(String? message) badResponse,
    required TResult Function() cancel,
    required TResult Function() connectionError,
    required TResult Function() unknown,
  }) {
    return unknown();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? invalidApiKey,
    TResult? Function()? connectionTimeout,
    TResult? Function()? sendTimeout,
    TResult? Function()? receiveTimeout,
    TResult? Function()? badCertificate,
    TResult? Function(String? message)? badResponse,
    TResult? Function()? cancel,
    TResult? Function()? connectionError,
    TResult? Function()? unknown,
  }) {
    return unknown?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? invalidApiKey,
    TResult Function()? connectionTimeout,
    TResult Function()? sendTimeout,
    TResult Function()? receiveTimeout,
    TResult Function()? badCertificate,
    TResult Function(String? message)? badResponse,
    TResult Function()? cancel,
    TResult Function()? connectionError,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(OpenSeaInvalidApiKey value) invalidApiKey,
    required TResult Function(OpenSeaConnectionTimeout value) connectionTimeout,
    required TResult Function(OpenSeaSendTimeout value) sendTimeout,
    required TResult Function(OpenSeaReceiveTimeout value) receiveTimeout,
    required TResult Function(OpenSeaBadCertificate value) badCertificate,
    required TResult Function(OpenSeaBadResponse value) badResponse,
    required TResult Function(OpenSeaCancel value) cancel,
    required TResult Function(OpenSeaConnectionError value) connectionError,
    required TResult Function(OpenSeaUnknown value) unknown,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(OpenSeaInvalidApiKey value)? invalidApiKey,
    TResult? Function(OpenSeaConnectionTimeout value)? connectionTimeout,
    TResult? Function(OpenSeaSendTimeout value)? sendTimeout,
    TResult? Function(OpenSeaReceiveTimeout value)? receiveTimeout,
    TResult? Function(OpenSeaBadCertificate value)? badCertificate,
    TResult? Function(OpenSeaBadResponse value)? badResponse,
    TResult? Function(OpenSeaCancel value)? cancel,
    TResult? Function(OpenSeaConnectionError value)? connectionError,
    TResult? Function(OpenSeaUnknown value)? unknown,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(OpenSeaInvalidApiKey value)? invalidApiKey,
    TResult Function(OpenSeaConnectionTimeout value)? connectionTimeout,
    TResult Function(OpenSeaSendTimeout value)? sendTimeout,
    TResult Function(OpenSeaReceiveTimeout value)? receiveTimeout,
    TResult Function(OpenSeaBadCertificate value)? badCertificate,
    TResult Function(OpenSeaBadResponse value)? badResponse,
    TResult Function(OpenSeaCancel value)? cancel,
    TResult Function(OpenSeaConnectionError value)? connectionError,
    TResult Function(OpenSeaUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class OpenSeaUnknown implements OpenSeaApiFailure {
  const factory OpenSeaUnknown() = _$OpenSeaUnknownImpl;
}
